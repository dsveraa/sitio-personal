{
  "version": 3,
  "sources": ["../../../../../node_modules/openapi-fetch/dist/index.js", "../../../../../node_modules/submitjson/dist/index.js"],
  "sourcesContent": ["// settings & const\nconst DEFAULT_HEADERS = {\n  \"Content-Type\": \"application/json\",\n};\n\n/**\n * Create an openapi-fetch client.\n * @type {import(\"./index.js\").default}\n */\nexport default function createClient(clientOptions) {\n  const {\n    fetch: baseFetch = globalThis.fetch,\n    querySerializer: globalQuerySerializer,\n    bodySerializer: globalBodySerializer,\n    ...baseOptions\n  } = clientOptions ?? {};\n  let baseUrl = baseOptions.baseUrl ?? \"\";\n  if (baseUrl.endsWith(\"/\")) {\n    baseUrl = baseUrl.slice(0, -1); // remove trailing slash\n  }\n\n  /**\n   * Per-request fetch (keeps settings created in createClient()\n   * @param {string} url\n   * @param {import('./index.js').FetchOptions} fetchOptions\n   */\n  async function coreFetch(url, fetchOptions) {\n    const {\n      fetch = baseFetch,\n      headers,\n      body: requestBody,\n      params = {},\n      parseAs = \"json\",\n      querySerializer = globalQuerySerializer ?? defaultQuerySerializer,\n      bodySerializer = globalBodySerializer ?? defaultBodySerializer,\n      ...init\n    } = fetchOptions || {};\n\n    // URL\n    const finalURL = createFinalURL(url, {\n      baseUrl,\n      params,\n      querySerializer,\n    });\n    const finalHeaders = mergeHeaders(\n      DEFAULT_HEADERS,\n      clientOptions?.headers,\n      headers,\n      params.header,\n    );\n\n    // fetch!\n    const requestInit = {\n      redirect: \"follow\",\n      ...baseOptions,\n      ...init,\n      headers: finalHeaders,\n    };\n\n    if (requestBody) {\n      requestInit.body = bodySerializer(requestBody);\n    }\n    // remove `Content-Type` if serialized body is FormData; browser will correctly set Content-Type & boundary expression\n    if (requestInit.body instanceof FormData) {\n      finalHeaders.delete(\"Content-Type\");\n    }\n\n    const response = await fetch(finalURL, requestInit);\n\n    // handle empty content\n    // note: we return `{}` because we want user truthy checks for `.data` or `.error` to succeed\n    if (\n      response.status === 204 ||\n      response.headers.get(\"Content-Length\") === \"0\"\n    ) {\n      return response.ok ? { data: {}, response } : { error: {}, response };\n    }\n\n    // parse response (falling back to .text() when necessary)\n    if (response.ok) {\n      // if \"stream\", skip parsing entirely\n      if (parseAs === \"stream\") {\n        // fix for bun: bun consumes response.body, therefore clone before accessing\n        // TODO: test this?\n        return { data: response.clone().body, response };\n      }\n      const cloned = response.clone();\n      return {\n        data:\n          typeof cloned[parseAs] === \"function\"\n            ? await cloned[parseAs]()\n            : await cloned.text(),\n        response,\n      };\n    }\n\n    // handle errors (always parse as .json() or .text())\n    let error = {};\n    try {\n      error = await response.clone().json();\n    } catch {\n      error = await response.clone().text();\n    }\n    return { error, response };\n  }\n\n  return {\n    /** Call a GET endpoint */\n    async GET(url, init) {\n      return coreFetch(url, { ...init, method: \"GET\" });\n    },\n    /** Call a PUT endpoint */\n    async PUT(url, init) {\n      return coreFetch(url, { ...init, method: \"PUT\" });\n    },\n    /** Call a POST endpoint */\n    async POST(url, init) {\n      return coreFetch(url, { ...init, method: \"POST\" });\n    },\n    /** Call a DELETE endpoint */\n    async DELETE(url, init) {\n      return coreFetch(url, { ...init, method: \"DELETE\" });\n    },\n    /** Call a OPTIONS endpoint */\n    async OPTIONS(url, init) {\n      return coreFetch(url, { ...init, method: \"OPTIONS\" });\n    },\n    /** Call a HEAD endpoint */\n    async HEAD(url, init) {\n      return coreFetch(url, { ...init, method: \"HEAD\" });\n    },\n    /** Call a PATCH endpoint */\n    async PATCH(url, init) {\n      return coreFetch(url, { ...init, method: \"PATCH\" });\n    },\n    /** Call a TRACE endpoint */\n    async TRACE(url, init) {\n      return coreFetch(url, { ...init, method: \"TRACE\" });\n    },\n  };\n}\n\n// utils\n\n/**\n * Serialize query params to string\n * @type {import(\"./index.js\").defaultQuerySerializer}\n */\nexport function defaultQuerySerializer(q) {\n  const search = [];\n  if (q && typeof q === \"object\") {\n    for (const [k, v] of Object.entries(q)) {\n      const value = defaultQueryParamSerializer([k], v);\n      if (value) {\n        search.push(value);\n      }\n    }\n  }\n  return search.join(\"&\");\n}\n\n/**\n * Serialize query param schema types according to expected default OpenAPI 3.x behavior\n * @type {import(\"./index.js\").defaultQueryParamSerializer}\n */\nexport function defaultQueryParamSerializer(key, value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"string\") {\n    return `${deepObjectPath(key)}=${encodeURIComponent(value)}`;\n  }\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return `${deepObjectPath(key)}=${String(value)}`;\n  }\n  if (Array.isArray(value)) {\n    if (!value.length) {\n      return undefined;\n    }\n    const nextValue = [];\n    for (const item of value) {\n      const next = defaultQueryParamSerializer(key, item);\n      if (next !== undefined) {\n        nextValue.push(next);\n      }\n    }\n    return nextValue.join(`&`);\n  }\n  if (typeof value === \"object\") {\n    if (!Object.keys(value).length) {\n      return undefined;\n    }\n    const nextValue = [];\n    for (const [k, v] of Object.entries(value)) {\n      if (v !== undefined && v !== null) {\n        const next = defaultQueryParamSerializer([...key, k], v);\n        if (next !== undefined) {\n          nextValue.push(next);\n        }\n      }\n    }\n    return nextValue.join(\"&\");\n  }\n  return encodeURIComponent(`${deepObjectPath(key)}=${String(value)}`);\n}\n\n/**\n * Flatten a node path into a deepObject string\n * @type {import(\"./index.js\").deepObjectPath}\n */\nfunction deepObjectPath(path) {\n  let output = path[0];\n  for (const k of path.slice(1)) {\n    output += `[${k}]`;\n  }\n  return output;\n}\n\n/**\n * Serialize body object to string\n * @type {import(\"./index.js\").defaultBodySerializer}\n */\nexport function defaultBodySerializer(body) {\n  return JSON.stringify(body);\n}\n\n/**\n * Construct URL string from baseUrl and handle path and query params\n * @type {import(\"./index.js\").createFinalURL}\n */\nexport function createFinalURL(pathname, options) {\n  let finalURL = `${options.baseUrl}${pathname}`;\n  if (options.params.path) {\n    for (const [k, v] of Object.entries(options.params.path)) {\n      finalURL = finalURL.replace(`{${k}}`, encodeURIComponent(String(v)));\n    }\n  }\n  const search = options.querySerializer(options.params.query ?? {});\n  if (search) {\n    finalURL += `?${search}`;\n  }\n  return finalURL;\n}\n\n/**\n * Merge headers a and b, with b taking priority\n * @type {import(\"./index.js\").mergeHeaders}\n */\nexport function mergeHeaders(...allHeaders) {\n  const headers = new Headers();\n  for (const headerSet of allHeaders) {\n    if (!headerSet || typeof headerSet !== \"object\") {\n      continue;\n    }\n    const iterator =\n      headerSet instanceof Headers\n        ? headerSet.entries()\n        : Object.entries(headerSet);\n    for (const [k, v] of iterator) {\n      if (v === null) {\n        headers.delete(k);\n      } else if (v !== undefined) {\n        headers.set(k, v);\n      }\n    }\n  }\n  return headers;\n}\n", "// index.ts\nimport createClient from \"openapi-fetch\";\nvar { POST } = createClient({\n  baseUrl: \"https://api.submitjson.com/\"\n});\nvar SubmitJSON = class {\n  apiKey;\n  endpointSlug;\n  options;\n  constructor(config) {\n    this.apiKey = config.apiKey;\n    this.endpointSlug = config.endpoint;\n    this.options = config.options;\n  }\n  getHeaders() {\n    return {\n      \"X-API-Key\": this.apiKey\n    };\n  }\n  async submit(data, options, endpoint) {\n    try {\n      let d;\n      if (data instanceof FormData) {\n        JSON.stringify(Object.fromEntries(data));\n        d = Object.fromEntries(data);\n      } else if (typeof data === \"string\") {\n        const s = JSON.parse(data);\n        if (typeof s !== \"object\")\n          throw new Error(`\\u2620\\uFE0F The string you pass in must parse into a valid JSON object e.g. { your: 'string' }`);\n        d = s;\n      } else if (typeof data === \"object\") {\n        JSON.stringify(data);\n        d = data;\n      } else {\n        throw new TypeError(\"\\u2620\\uFE0F The first argument must be a valid JSON object, string, or FormData\");\n      }\n      if (typeof options === \"string\")\n        endpoint = options;\n      const endpointSlug = endpoint || this.endpointSlug;\n      if (endpointSlug === void 0)\n        throw new Error(\"\\u2620\\uFE0F No endpoint defined. Add one to your client configuration or to this submit call.\");\n      const body = { data: d };\n      let o;\n      if (typeof this.options === \"object\")\n        o = this.options;\n      if (typeof options === \"object\")\n        o ? o = { ...o, ...options } : o = options;\n      if (o) {\n        const { emailNotification, submissionFormat, submissionSound, emailReplyTo, emailTo, emailSubject, emailBranding } = o;\n        const options2 = { emailNotification, submissionFormat, submissionSound, emailReplyTo, emailTo, emailBranding, emailSubject };\n        Object.keys(options2).forEach((key) => options2 && options2[key] === void 0 && delete options2[key]);\n        if (Object.keys(options2).length > 0)\n          body.options = options2;\n      }\n      const { data: submission, error } = await POST(\"/v1/submit/{endpointSlug}\", {\n        headers: this.getHeaders(),\n        params: {\n          path: { endpointSlug }\n        },\n        body\n      });\n      if (error)\n        throw new Error(error.message);\n      return submission;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n};\nexport {\n  SubmitJSON as default\n};\n"],
  "mappings": "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",
  "names": ["_a"]
}
